//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v10.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AccountClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param returnUrl (optional)
   * @param body (optional)
   * @return Success
   */
  login(
    returnUrl?: string | undefined,
    body?: LoginDto | undefined
  ): Promise<boolean> {
    let url_ = this.baseUrl + "/api/Account/login?";
    if (returnUrl === null)
      throw new Error("The parameter 'returnUrl' cannot be null.");
    else if (returnUrl !== undefined)
      url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLogin(_response);
    });
  }

  protected processLogin(response: Response): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ProblemDetails);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        resultdefault =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ProblemDetails);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * (Auth)
   * @return Success
   */
  logout(): Promise<void> {
    let url_ = this.baseUrl + "/api/Account/logout";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLogout(_response);
    });
  }

  protected processLogout(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class AdminClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  registerUser(body?: RegisterDto | undefined): Promise<SMSUser> {
    let url_ = this.baseUrl + "/api/Admin/register-user";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRegisterUser(_response);
    });
  }

  protected processRegisterUser(response: Response): Promise<SMSUser> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as SMSUser);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SMSUser>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getRoles(): Promise<ApplicationRole[]> {
    let url_ = this.baseUrl + "/api/Admin/roles";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetRoles(_response);
    });
  }

  protected processGetRoles(response: Response): Promise<ApplicationRole[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ApplicationRole[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ApplicationRole[]>(null as any);
  }

  /**
   * (Auth)
   * @param userId (optional)
   * @param body (optional)
   * @return Success
   */
  addClaims(
    userId?: string | undefined,
    body?: { [key: string]: string } | undefined
  ): Promise<UserDto> {
    let url_ = this.baseUrl + "/api/Admin/user/add-claims?";
    if (userId === null)
      throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddClaims(_response);
    });
  }

  protected processAddClaims(response: Response): Promise<UserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserDto);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ProblemDetails);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        resultdefault =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ProblemDetails);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * (Auth)
   * @return Success
   */
  users(): Promise<UserDetail[]> {
    let url_ = this.baseUrl + "/api/Admin/users";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUsers(_response);
    });
  }

  protected processUsers(response: Response): Promise<UserDetail[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as UserDetail[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserDetail[]>(null as any);
  }

  /**
   * (Auth)
   * @param id (optional)
   * @return Success
   */
  getUserDetail(id?: string | undefined): Promise<UserDetail> {
    let url_ = this.baseUrl + "/api/Admin/users/:id?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetUserDetail(_response);
    });
  }

  protected processGetUserDetail(response: Response): Promise<UserDetail> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserDetail);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserDetail>(null as any);
  }

  /**
   * (Auth)
   * @param id (optional)
   * @param role (optional)
   * @return Success
   */
  addUserRole(
    id?: string | undefined,
    role?: string | undefined
  ): Promise<UserDetail> {
    let url_ = this.baseUrl + "/api/Admin/users/:id/:role?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (role === null) throw new Error("The parameter 'role' cannot be null.");
    else if (role !== undefined)
      url_ += "role=" + encodeURIComponent("" + role) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddUserRole(_response);
    });
  }

  protected processAddUserRole(response: Response): Promise<UserDetail> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserDetail);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ProblemDetails);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        resultdefault =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ProblemDetails);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * (Auth)
   * @param id (optional)
   * @param role (optional)
   * @return Success
   */
  removeUserRole(
    id?: string | undefined,
    role?: string | undefined
  ): Promise<UserDetail> {
    let url_ = this.baseUrl + "/api/Admin/users/:id/:role?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (role === null) throw new Error("The parameter 'role' cannot be null.");
    else if (role !== undefined)
      url_ += "role=" + encodeURIComponent("" + role) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRemoveUserRole(_response);
    });
  }

  protected processRemoveUserRole(response: Response): Promise<UserDetail> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserDetail);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ProblemDetails);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        resultdefault =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ProblemDetails);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }
}

export class AllocationClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllocationById(id: number): Promise<CreateAllocationCommand> {
    let url_ = this.baseUrl + "/api/Allocation/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllocationById(_response);
    });
  }

  protected processGetAllocationById(
    response: Response
  ): Promise<CreateAllocationCommand> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateAllocationCommand);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateAllocationCommand>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getApprovedAllocationLookup(id: number): Promise<CreateAllocationCommand> {
    let url_ = this.baseUrl + "/api/Allocation/{id}/AllocationLookup";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetApprovedAllocationLookup(_response);
    });
  }

  protected processGetApprovedAllocationLookup(
    response: Response
  ): Promise<CreateAllocationCommand> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateAllocationCommand);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateAllocationCommand>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  approvePending(
    id: number,
    body?: ApproveAllocationCommand | undefined
  ): Promise<ApproveAllocationCommand[]> {
    let url_ = this.baseUrl + "/api/Allocation/{id}/ApprovePending";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApprovePending(_response);
    });
  }

  protected processApprovePending(
    response: Response
  ): Promise<ApproveAllocationCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ApproveAllocationCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ApproveAllocationCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  updateAllocation(
    id: number,
    body?: UpdateAllocationCommand | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Allocation/{id}/UpdateAllocation";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateAllocation(_response);
    });
  }

  protected processUpdateAllocation(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  createAllocation(
    body?: CreateAllocationCommand | undefined
  ): Promise<AllocationDtos[]> {
    let url_ = this.baseUrl + "/api/Allocation/CreateAllocation";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateAllocation(_response);
    });
  }

  protected processCreateAllocation(
    response: Response
  ): Promise<AllocationDtos[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as AllocationDtos[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<AllocationDtos[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllAllocations(): Promise<CreateAllocationCommand[]> {
    let url_ = this.baseUrl + "/api/Allocation/GetAllAlloation";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllAllocations(_response);
    });
  }

  protected processGetAllAllocations(
    response: Response
  ): Promise<CreateAllocationCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateAllocationCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateAllocationCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllAllocationsForApproval(): Promise<CreateAllocationCommand[]> {
    let url_ = this.baseUrl + "/api/Allocation/GetAllocationForApproval";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllAllocationsForApproval(_response);
    });
  }

  protected processGetAllAllocationsForApproval(
    response: Response
  ): Promise<CreateAllocationCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateAllocationCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateAllocationCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllAllocationsForReturn(): Promise<CreateAllocationCommand[]> {
    let url_ = this.baseUrl + "/api/Allocation/GetAllReturnAllocation";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllAllocationsForReturn(_response);
    });
  }

  protected processGetAllAllocationsForReturn(
    response: Response
  ): Promise<CreateAllocationCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateAllocationCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateAllocationCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  returnAllocation(body?: ReturnAllocationCommand | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/Allocation/ReturnAllocation";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processReturnAllocation(_response);
    });
  }

  protected processReturnAllocation(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class DocumentsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  get(id: string): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/Documents/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGet(_response);
    });
  }

  protected processGet(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class GroupClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  getSubscriptionGroupById(
    id: number
  ): Promise<CreateSubscriptionGroupCommand> {
    let url_ = this.baseUrl + "/api/Group/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSubscriptionGroupById(_response);
    });
  }

  protected processGetSubscriptionGroupById(
    response: Response
  ): Promise<CreateSubscriptionGroupCommand> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionGroupCommand);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionGroupCommand>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  createSubscriptionGroup(
    body?: CreateSubscriptionGroupCommand | undefined
  ): Promise<CreateSubscriptionGroupCommand[]> {
    let url_ = this.baseUrl + "/api/Group/CreateSubscriptionGroup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateSubscriptionGroup(_response);
    });
  }

  protected processCreateSubscriptionGroup(
    response: Response
  ): Promise<CreateSubscriptionGroupCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionGroupCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionGroupCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllSubscriptionGroups(): Promise<CreateSubscriptionGroupCommand[]> {
    let url_ = this.baseUrl + "/api/Group/GetAllSubscriptionGroups";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllSubscriptionGroups(_response);
    });
  }

  protected processGetAllSubscriptionGroups(
    response: Response
  ): Promise<CreateSubscriptionGroupCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionGroupCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionGroupCommand[]>(null as any);
  }
}

export class LookupsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllLookups(): Promise<LookupsDto> {
    let url_ = this.baseUrl + "/api/Lookups/all";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllLookups(_response);
    });
  }

  protected processGetAllLookups(response: Response): Promise<LookupsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as LookupsDto);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<LookupsDto>(null as any);
  }
}

export class ParValueClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  getParValueById(id: number): Promise<CreateParValueCommand> {
    let url_ = this.baseUrl + "/api/ParValue/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetParValueById(_response);
    });
  }

  protected processGetParValueById(
    response: Response
  ): Promise<CreateParValueCommand> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateParValueCommand);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateParValueCommand>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  createParValue(
    body?: CreateParValueCommand | undefined
  ): Promise<CreateParValueCommand[]> {
    let url_ = this.baseUrl + "/api/ParValue/CreateParValue";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateParValue(_response);
    });
  }

  protected processCreateParValue(
    response: Response
  ): Promise<CreateParValueCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateParValueCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateParValueCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllParvalues(): Promise<CreateParValueCommand[]> {
    let url_ = this.baseUrl + "/api/ParValue/GetAllParvalues";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllParvalues(_response);
    });
  }

  protected processGetAllParvalues(
    response: Response
  ): Promise<CreateParValueCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateParValueCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateParValueCommand[]>(null as any);
  }
}

export class PaymentsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  getPaymentById(id: number): Promise<PaymentDetailsDto> {
    let url_ = this.baseUrl + "/api/Payments/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPaymentById(_response);
    });
  }

  protected processGetPaymentById(
    response: Response
  ): Promise<PaymentDetailsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as PaymentDetailsDto);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentDetailsDto>(null as any);
  }

  /**
   * (Auth)
   * @param file (optional)
   * @return Success
   */
  addPaymentReciept(
    id: number,
    file?: FileParameter | undefined
  ): Promise<string> {
    let url_ = this.baseUrl + "/api/Payments/{id}/add-receipt";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.");
    else
      content_.append(
        "file",
        file.data,
        file.fileName ? file.fileName : "file"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddPaymentReciept(_response);
    });
  }

  protected processAddPaymentReciept(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as string);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getPaymentWithShareholderID(shareholderid: number): Promise<PaymentInfo[]> {
    let url_ =
      this.baseUrl +
      "/api/Payments/{shareholderid}/GetPaymentWithShareholderID";
    if (shareholderid === undefined || shareholderid === null)
      throw new Error("The parameter 'shareholderid' must be defined.");
    url_ = url_.replace(
      "{shareholderid}",
      encodeURIComponent("" + shareholderid)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPaymentWithShareholderID(_response);
    });
  }

  protected processGetPaymentWithShareholderID(
    response: Response
  ): Promise<PaymentInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as PaymentInfo[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentInfo[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  addNewPayment(body?: PaymentInfo | undefined): Promise<PaymentListVm[]> {
    let url_ = this.baseUrl + "/api/Payments/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddNewPayment(_response);
    });
  }

  protected processAddNewPayment(response: Response): Promise<PaymentListVm[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as PaymentListVm[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentListVm[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllPayments(): Promise<PaymentDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Payments/all";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllPayments(_response);
    });
  }

  protected processGetAllPayments(
    response: Response
  ): Promise<PaymentDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as PaymentDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getApprovePayments(): Promise<PaymentDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Payments/all/approve";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetApprovePayments(_response);
    });
  }

  protected processGetApprovePayments(
    response: Response
  ): Promise<PaymentDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as PaymentDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getPendingPayments(): Promise<PaymentDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Payments/all/pending";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPendingPayments(_response);
    });
  }

  protected processGetPendingPayments(
    response: Response
  ): Promise<PaymentDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as PaymentDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getReturnPayments(): Promise<PaymentDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Payments/all/return";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetReturnPayments(_response);
    });
  }

  protected processGetReturnPayments(
    response: Response
  ): Promise<PaymentDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as PaymentDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getReversePayments(): Promise<PaymentDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Payments/all/Reverse";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetReversePayments(_response);
    });
  }

  protected processGetReversePayments(
    response: Response
  ): Promise<PaymentDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as PaymentDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  approvePayment(
    body?: ApprovePaymentCommand | undefined
  ): Promise<ApprovePaymentCommand[]> {
    let url_ = this.baseUrl + "/api/Payments/Approve";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApprovePayment(_response);
    });
  }

  protected processApprovePayment(
    response: Response
  ): Promise<ApprovePaymentCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ApprovePaymentCommand[]);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ValidationProblemDetails);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ApprovePaymentCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  approveReversalPayment(
    body?: ApprovePaymentReversalCommand | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + "/api/Payments/ApproveReversal";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApproveReversalPayment(_response);
    });
  }

  protected processApproveReversalPayment(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as number);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  createReversalPayment(
    body?: CreatePaymentReversalCommand | undefined
  ): Promise<CreatePaymentReversalCommand[]> {
    let url_ = this.baseUrl + "/api/Payments/CreateReversal";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateReversalPayment(_response);
    });
  }

  protected processCreateReversalPayment(
    response: Response
  ): Promise<CreatePaymentReversalCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreatePaymentReversalCommand[]);
        return result200;
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ValidationProblemDetails);
        return throwException(
          "Not Found",
          status,
          _responseText,
          _headers,
          result404
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreatePaymentReversalCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  discardPayment(
    body?: DiscardPaymentCommand | undefined
  ): Promise<DiscardPaymentCommand[]> {
    let url_ = this.baseUrl + "/api/Payments/Discard";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDiscardPayment(_response);
    });
  }

  protected processDiscardPayment(
    response: Response
  ): Promise<DiscardPaymentCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as DiscardPaymentCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DiscardPaymentCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  returnPayment(
    body?: ReturnPaymentCommand | undefined
  ): Promise<ReturnPaymentCommand[]> {
    let url_ = this.baseUrl + "/api/Payments/Return";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processReturnPayment(_response);
    });
  }

  protected processReturnPayment(
    response: Response
  ): Promise<ReturnPaymentCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ReturnPaymentCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ReturnPaymentCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  updatePayment(
    body?: PaymentInfo | undefined
  ): Promise<UpdatePaymentCommand[]> {
    let url_ = this.baseUrl + "/api/Payments/update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdatePayment(_response);
    });
  }

  protected processUpdatePayment(
    response: Response
  ): Promise<UpdatePaymentCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as UpdatePaymentCommand[]);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ValidationProblemDetails);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UpdatePaymentCommand[]>(null as any);
  }
}

export class ShareholdersClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  getShareholderById(id: number): Promise<ShareholderDetailsDto> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetShareholderById(_response);
    });
  }

  protected processGetShareholderById(
    response: Response
  ): Promise<ShareholderDetailsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ShareholderDetailsDto);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShareholderDetailsDto>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  updateShareholder(
    id: number,
    body?: UpdateShareHolderCommand | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateShareholder(_response);
    });
  }

  protected processUpdateShareholder(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as number);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * (Auth)
   * @param file (optional)
   * @return Success
   */
  addShareholderPhoto(
    id: number,
    file?: FileParameter | undefined
  ): Promise<string> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/add-photo";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.");
    else
      content_.append(
        "file",
        file.data,
        file.fileName ? file.fileName : "file"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddShareholderPhoto(_response);
    });
  }

  protected processAddShareholderPhoto(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as string);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * (Auth)
   * @param file (optional)
   * @return Success
   */
  addShareholderSignature(
    id: number,
    file?: FileParameter | undefined
  ): Promise<string> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/add-signature";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.");
    else
      content_.append(
        "file",
        file.data,
        file.fileName ? file.fileName : "file"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddShareholderSignature(_response);
    });
  }

  protected processAddShareholderSignature(
    response: Response
  ): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as string);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  addShareholderAddress(
    id: number,
    body?: AddressDto | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/addresses";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddShareholderAddress(_response);
    });
  }

  protected processAddShareholderAddress(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as number);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  updateShareholderAddress(
    id: number,
    body?: AddressDto | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/addresses";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateShareholderAddress(_response);
    });
  }

  protected processUpdateShareholderAddress(
    response: Response
  ): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as number);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getShareholderAddresses(id: number): Promise<AddressDto[]> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/addresses";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetShareholderAddresses(_response);
    });
  }

  protected processGetShareholderAddresses(
    response: Response
  ): Promise<AddressDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as AddressDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<AddressDto[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  addShareholderContact(
    id: number,
    body?: ContactDto | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/contacts";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddShareholderContact(_response);
    });
  }

  protected processAddShareholderContact(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as number);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  updateShareholderContact(
    id: number,
    body?: ContactDto | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/contacts";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateShareholderContact(_response);
    });
  }

  protected processUpdateShareholderContact(
    response: Response
  ): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as number);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getShareholderContacts(id: number): Promise<ContactDto[]> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/contacts";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetShareholderContacts(_response);
    });
  }

  protected processGetShareholderContacts(
    response: Response
  ): Promise<ContactDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ContactDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ContactDto[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  getFamilies(
    id: number,
    body?: GetFamiliesRequest | undefined
  ): Promise<FamilyDto[]> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/families";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetFamilies(_response);
    });
  }

  protected processGetFamilies(response: Response): Promise<FamilyDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as FamilyDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FamilyDto[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  addFamilyMembers(
    id: number,
    body?: AddFamilyMembersRequest | undefined
  ): Promise<FamilyDto> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/families/add";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddFamilyMembers(_response);
    });
  }

  protected processAddFamilyMembers(response: Response): Promise<FamilyDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as FamilyDto);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FamilyDto>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  removeFamilyMember(
    id: number,
    body?: RemoveFamilyMembersRequest | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Shareholders/{id}/families/remove";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRemoveFamilyMember(_response);
    });
  }

  protected processRemoveFamilyMember(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  addNewShareholder(
    body?: CreateShareholderCommand | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + "/api/Shareholders/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddNewShareholder(_response);
    });
  }

  protected processAddNewShareholder(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as number);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ValidationProblemDetails);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllShareholders(): Promise<ShareholderDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Shareholders/all";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllShareholders(_response);
    });
  }

  protected processGetAllShareholders(
    response: Response
  ): Promise<ShareholderDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ShareholderDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShareholderDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @param name (optional)
   * @return Success
   */
  typeaheadSearch(name?: string | undefined): Promise<ShareholderBasicInfo[]> {
    let url_ = this.baseUrl + "/api/Shareholders/typeahead-search?";
    if (name === null) throw new Error("The parameter 'name' cannot be null.");
    else if (name !== undefined)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTypeaheadSearch(_response);
    });
  }

  protected processTypeaheadSearch(
    response: Response
  ): Promise<ShareholderBasicInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ShareholderBasicInfo[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShareholderBasicInfo[]>(null as any);
  }
}

export class SubscriptionAllocationClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  getSubscriptionAllocationByID(
    id: number
  ): Promise<GetSubscriptionAllocationQuery> {
    let url_ = this.baseUrl + "/api/SubscriptionAllocation/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSubscriptionAllocationByID(_response);
    });
  }

  protected processGetSubscriptionAllocationByID(
    response: Response
  ): Promise<GetSubscriptionAllocationQuery> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as GetSubscriptionAllocationQuery);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<GetSubscriptionAllocationQuery>(null as any);
  }
}

export class SubscriptionsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @param file (optional)
   * @return Success
   */
  addSubscriptionDocument(
    id: number,
    file?: FileParameter | undefined
  ): Promise<string> {
    let url_ = this.baseUrl + "/api/Subscriptions/{id}/add-subscriptionDoc";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.");
    else
      content_.append(
        "file",
        file.data,
        file.fileName ? file.fileName : "file"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddSubscriptionDocument(_response);
    });
  }

  protected processAddSubscriptionDocument(
    response: Response
  ): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as string);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  approveReversal(
    id: number,
    body?: ApproveReversalSubscriptionCommand | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Subscriptions/{id}/ApproveReversal";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApproveReversal(_response);
    });
  }

  protected processApproveReversal(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  approveSubscriptions(
    id: number,
    body?: ApproveSubscriptionCommand | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Subscriptions/{id}/ApproveSubscriptions";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApproveSubscriptions(_response);
    });
  }

  protected processApproveSubscriptions(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  createReversalSubscriptions(
    id: number,
    body?: CreateReverseSubscriptionCommand | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Subscriptions/{id}/CreateReversal";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateReversalSubscriptions(_response);
    });
  }

  protected processCreateReversalSubscriptions(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getSubscriptionWithID(id: number): Promise<CreateSubscriptionCommand> {
    let url_ = this.baseUrl + "/api/Subscriptions/{id}/GetSubscriptionWithID";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSubscriptionWithID(_response);
    });
  }

  protected processGetSubscriptionWithID(
    response: Response
  ): Promise<CreateSubscriptionCommand> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionCommand);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionCommand>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  rejectSubscriptions(
    id: number,
    body?: RejectSubscriptionCommand | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Subscriptions/{id}/RejectSubscriptions";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRejectSubscriptions(_response);
    });
  }

  protected processRejectSubscriptions(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  updateSubscription(
    id: number,
    body?: UpdateSubscriptionCommand | undefined
  ): Promise<UpdateSubscriptionCommand[]> {
    let url_ = this.baseUrl + "/api/Subscriptions/{id}/UpdateSubscription";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateSubscription(_response);
    });
  }

  protected processUpdateSubscription(
    response: Response
  ): Promise<UpdateSubscriptionCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as UpdateSubscriptionCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UpdateSubscriptionCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getSubscriptionByShareholderID(
    shareholderid: number
  ): Promise<CreateSubscriptionCommand[]> {
    let url_ =
      this.baseUrl +
      "/api/Subscriptions/{shareholderid}/GetSubscriptionByListShareholderID";
    if (shareholderid === undefined || shareholderid === null)
      throw new Error("The parameter 'shareholderid' must be defined.");
    url_ = url_.replace(
      "{shareholderid}",
      encodeURIComponent("" + shareholderid)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSubscriptionByShareholderID(_response);
    });
  }

  protected processGetSubscriptionByShareholderID(
    response: Response
  ): Promise<CreateSubscriptionCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getSubscriptionDetailByShareholderID(
    shareholderid: number
  ): Promise<CreateSubscriptionCommand> {
    let url_ =
      this.baseUrl +
      "/api/Subscriptions/{shareholderid}/GetSubscriptionDetailByShareholderID";
    if (shareholderid === undefined || shareholderid === null)
      throw new Error("The parameter 'shareholderid' must be defined.");
    url_ = url_.replace(
      "{shareholderid}",
      encodeURIComponent("" + shareholderid)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSubscriptionDetailByShareholderID(_response);
    });
  }

  protected processGetSubscriptionDetailByShareholderID(
    response: Response
  ): Promise<CreateSubscriptionCommand> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionCommand);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionCommand>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getSubscriptionWithShareholderID(
    shareholderid: number
  ): Promise<CreateSubscriptionCommand[]> {
    let url_ =
      this.baseUrl +
      "/api/Subscriptions/{shareholderid}/GetSubscriptionWithShareholderID";
    if (shareholderid === undefined || shareholderid === null)
      throw new Error("The parameter 'shareholderid' must be defined.");
    url_ = url_.replace(
      "{shareholderid}",
      encodeURIComponent("" + shareholderid)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSubscriptionWithShareholderID(_response);
    });
  }

  protected processGetSubscriptionWithShareholderID(
    response: Response
  ): Promise<CreateSubscriptionCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllSubscriptions(): Promise<CreateSubscriptionCommand[]> {
    let url_ = this.baseUrl + "/api/Subscriptions/AllSubscriptions";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllSubscriptions(_response);
    });
  }

  protected processGetAllSubscriptions(
    response: Response
  ): Promise<CreateSubscriptionCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  createSubscriptions(
    body?: CreateSubscriptionCommand | undefined
  ): Promise<CreateSubscriptionCommand[]> {
    let url_ = this.baseUrl + "/api/Subscriptions/CreateSubscriptions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateSubscriptions(_response);
    });
  }

  protected processCreateSubscriptions(
    response: Response
  ): Promise<CreateSubscriptionCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionCommand[]);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ValidationProblemDetails);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllReturnSubscription(): Promise<CreateSubscriptionCommand[]> {
    let url_ = this.baseUrl + "/api/Subscriptions/GetAllReturnSubscription";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllReturnSubscription(_response);
    });
  }

  protected processGetAllReturnSubscription(
    response: Response
  ): Promise<CreateSubscriptionCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  returnSubscription(
    body?: ReturnSubscriptionCommand | undefined
  ): Promise<ReturnSubscriptionCommand[]> {
    let url_ = this.baseUrl + "/api/Subscriptions/ReturnSubscription";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processReturnSubscription(_response);
    });
  }

  protected processReturnSubscription(
    response: Response
  ): Promise<ReturnSubscriptionCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ReturnSubscriptionCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ReturnSubscriptionCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllSubscriptionForReversal(): Promise<CreateReverseSubscriptionCommand[]> {
    let url_ = this.baseUrl + "/api/Subscriptions/ReversalWorkflow";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllSubscriptionForReversal(_response);
    });
  }

  protected processGetAllSubscriptionForReversal(
    response: Response
  ): Promise<CreateReverseSubscriptionCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateReverseSubscriptionCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateReverseSubscriptionCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllSubscriptionForApproval(): Promise<CreateSubscriptionCommand[]> {
    let url_ =
      this.baseUrl + "/api/Subscriptions/SubscriptionWorkflowForApproval";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllSubscriptionForApproval(_response);
    });
  }

  protected processGetAllSubscriptionForApproval(
    response: Response
  ): Promise<CreateSubscriptionCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateSubscriptionCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateSubscriptionCommand[]>(null as any);
  }
}

export class TransfersClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  getTransferById(id: number): Promise<TransferDetailsDto> {
    let url_ = this.baseUrl + "/api/Transfers/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetTransferById(_response);
    });
  }

  protected processGetTransferById(
    response: Response
  ): Promise<TransferDetailsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as TransferDetailsDto);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TransferDetailsDto>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  approveReversalTransfer(
    id: number,
    body?: ApproveReverseTransferCommand | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Transfers/{id}/ApproveReversalTransfer";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApproveReversalTransfer(_response);
    });
  }

  protected processApproveReversalTransfer(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  createReversalTransfer(
    id: number,
    body?: CreateReverseTransferCommand | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Transfers/{id}/CreateReversalTransfer";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateReversalTransfer(_response);
    });
  }

  protected processCreateReversalTransfer(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getTransferWithID(id: number): Promise<TransferInfo> {
    let url_ = this.baseUrl + "/api/Transfers/{id}/GetTransferWithID";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetTransferWithID(_response);
    });
  }

  protected processGetTransferWithID(
    response: Response
  ): Promise<TransferInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as TransferInfo);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TransferInfo>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  addNewTransfer(body?: TransferInfo | undefined): Promise<number> {
    let url_ = this.baseUrl + "/api/Transfers/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddNewTransfer(_response);
    });
  }

  protected processAddNewTransfer(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as number);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllTransfer(): Promise<TransferDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Transfers/all";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllTransfer(_response);
    });
  }

  protected processGetAllTransfer(
    response: Response
  ): Promise<TransferDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as TransferDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TransferDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getApproveTransfers(): Promise<TransferDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Transfers/all/approve";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetApproveTransfers(_response);
    });
  }

  protected processGetApproveTransfers(
    response: Response
  ): Promise<TransferDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as TransferDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TransferDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getPendingTransfers(): Promise<TransferDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Transfers/all/pending";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPendingTransfers(_response);
    });
  }

  protected processGetPendingTransfers(
    response: Response
  ): Promise<TransferDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as TransferDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TransferDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getReturnTransfers(): Promise<TransferDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Transfers/all/return";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetReturnTransfers(_response);
    });
  }

  protected processGetReturnTransfers(
    response: Response
  ): Promise<TransferDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as TransferDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TransferDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getReverseTransfers(): Promise<TransferDetailsDto[]> {
    let url_ = this.baseUrl + "/api/Transfers/all/Reverse";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetReverseTransfers(_response);
    });
  }

  protected processGetReverseTransfers(
    response: Response
  ): Promise<TransferDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as TransferDetailsDto[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TransferDetailsDto[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllTransfers(): Promise<TransferInfo[]> {
    let url_ = this.baseUrl + "/api/Transfers/AllTransfers";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllTransfers(_response);
    });
  }

  protected processGetAllTransfers(
    response: Response
  ): Promise<TransferInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as TransferInfo[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TransferInfo[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  allTransfersDetail(): Promise<CreateTransferDetailCommand[]> {
    let url_ = this.baseUrl + "/api/Transfers/AllTransfersDetail";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAllTransfersDetail(_response);
    });
  }

  protected processAllTransfersDetail(
    response: Response
  ): Promise<CreateTransferDetailCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateTransferDetailCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateTransferDetailCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  approveTransfer(body?: ApproveTransferCommand | undefined): Promise<number> {
    let url_ = this.baseUrl + "/api/Transfers/ApproveTransfer";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApproveTransfer(_response);
    });
  }

  protected processApproveTransfer(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as number);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  createMultipleTransfers(
    body?: CreateMultipleTransferCommand | undefined
  ): Promise<CreateMultipleTransferCommand> {
    let url_ = this.baseUrl + "/api/Transfers/CreateMultipleTransfers";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateMultipleTransfers(_response);
    });
  }

  protected processCreateMultipleTransfers(
    response: Response
  ): Promise<CreateMultipleTransferCommand> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateMultipleTransferCommand);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateMultipleTransferCommand>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  createTransfers(
    body?: CreateTransferCommand | undefined
  ): Promise<CreateTransferCommand[]> {
    let url_ = this.baseUrl + "/api/Transfers/CreateTransfers";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateTransfers(_response);
    });
  }

  protected processCreateTransfers(
    response: Response
  ): Promise<CreateTransferCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateTransferCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateTransferCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  discardTransfer(
    body?: DiscardTransferCommand | undefined
  ): Promise<DiscardTransferCommand[]> {
    let url_ = this.baseUrl + "/api/Transfers/Discard";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDiscardTransfer(_response);
    });
  }

  protected processDiscardTransfer(
    response: Response
  ): Promise<DiscardTransferCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as DiscardTransferCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DiscardTransferCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  returnTransfer(
    body?: ReturnTransferCommand | undefined
  ): Promise<ReturnTransferCommand[]> {
    let url_ = this.baseUrl + "/api/Transfers/Return";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processReturnTransfer(_response);
    });
  }

  protected processReturnTransfer(
    response: Response
  ): Promise<ReturnTransferCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ReturnTransferCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ReturnTransferCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @return Success
   */
  getAllTransferForReversal(): Promise<CreateReverseTransferCommand[]> {
    let url_ = this.baseUrl + "/api/Transfers/ReversalWorkflow";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllTransferForReversal(_response);
    });
  }

  protected processGetAllTransferForReversal(
    response: Response
  ): Promise<CreateReverseTransferCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as CreateReverseTransferCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CreateReverseTransferCommand[]>(null as any);
  }

  /**
   * (Auth)
   * @param body (optional)
   * @return Success
   */
  updateTransfer(
    body?: TransferInfo | undefined
  ): Promise<UpdateTransferCommand[]> {
    let url_ = this.baseUrl + "/api/Transfers/update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateTransfer(_response);
    });
  }

  protected processUpdateTransfer(
    response: Response
  ): Promise<UpdateTransferCommand[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as UpdateTransferCommand[]);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UpdateTransferCommand[]>(null as any);
  }
}

export class UsersClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * (Auth)
   * @return Success
   */
  currentUserInfo(): Promise<UserDto> {
    let url_ = this.baseUrl + "/api/Users/current";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCurrentUserInfo(_response);
    });
  }

  protected processCurrentUserInfo(response: Response): Promise<UserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserDto);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserDto>(null as any);
  }
}

export interface AddFamilyMembersRequest {
  familyId?: number | undefined;
  members?: number[] | undefined;
}

export interface AddressDto {
  id?: number;
  countryId?: number;
  city?: string | undefined;
  subCity?: string | undefined;
  kebele?: string | undefined;
  woreda?: string | undefined;
  houseNumber?: string | undefined;
  shareholderId?: number;
}

export interface AllocationDtos {
  id?: number;
  allocationName?: string | undefined;
  allocationDate?: string;
  allocationStatus?: AllocationStatus;
  allocationAmount?: number;
  fromDate?: string;
  toDate?: string;
  allocationDescription?: string | undefined;
  allocationDto?: CreateAllocationCommand[] | undefined;
}

export enum AllocationStatus {
  Pending = 1,
  Approved = 2,
  Returned = 3,
  Cancle = 4,
  Active = 7,
  Discard = 12,
  Inactive = 13,
}

export interface ApplicationRole {
  name?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
}

export enum ApprovalStatus {
  Draft = 1,
  Submitted = 2,
  Rejected = 3,
  Approved = 4,
}

export interface ApproveAllocationCommand {
  id?: number;
  allocationName?: string | undefined;
  allocationDate?: string;
  allocationStatus?: AllocationStatus;
  allocationAmount?: number;
  fromDate?: string;
  toDate?: string;
  allocationDescription?: string | undefined;
}

export interface ApprovePaymentCommand {
  id?: number;
}

export interface ApprovePaymentReversalCommand {
  id?: number;
}

export interface ApproveReversalSubscriptionCommand {
  id?: number;
}

export interface ApproveReverseTransferCommand {
  id?: number;
}

export interface ApproveSubscriptionCommand {
  id?: number;
}

export interface ApproveTransferCommand {
  id?: number;
  remark?: string | undefined;
}

export interface BranchDto {
  id?: number;
  districtID?: number;
  branchName?: string | undefined;
  branchCode?: string | undefined;
}

export interface Claim {
  claimType?: string | undefined;
  claimValue?: string | undefined;
}

export interface ContactDto {
  id?: number;
  shareholderId?: number;
  type?: ContactType;
  value?: string | undefined;
  readonly description?: string | undefined;
}

export enum ContactType {
  Email = 1,
  CellPhone = 2,
  HomePhone = 3,
  WorkPhone = 4,
  Fax = 5,
}

export interface CountryDto {
  id?: number;
  name?: string | undefined;
  nationality?: string | undefined;
}

export interface CreateAllocationCommand {
  id?: number;
  allocationName?: string | undefined;
  allocationDate?: string;
  allocationStatus?: AllocationStatus;
  allocationAmount?: number;
  fromDate?: string;
  toDate?: string;
  allocationDescription?: string | undefined;
}

export interface CreateMultipleTransferCommand {
  id?: number;
  fromShareHolderId?: number;
  toShareHolderId?: number;
  transferId?: number;
  entitledAmount?: number;
  isMultipleTransfer?: boolean | undefined;
}

export interface CreateParValueCommand {
  id?: number;
  parValueAmount?: number;
  parValueDescription?: string | undefined;
  fromDate?: string;
  toDate?: string;
}

export interface CreatePaymentReversalCommand {
  id?: number;
}

export interface CreateReverseSubscriptionCommand {
  id?: number;
  subscriptionID?: string | undefined;
  subscriptionShareHolderID?: number;
  subscriptionAllocationID?: number;
  subscriptionTransferID?: number;
  subscriptionAmount?: number;
  subscriptionBalance?: number;
  subscriptionDate?: string | undefined;
  subscriptionPaidUpAmount?: number;
  subscriptionOutstandingAmount?: number;
  subscriptionGroupID?: number;
  subscriptionDistrictID?: string | undefined;
  subscriptionBranchID?: number;
  approvedBy?: string | undefined;
  subscriptionRemark?: string | undefined;
  subscriptionStatus?: SubscriptionStatus;
  photoUrl?: string | undefined;
  photoId?: string | undefined;
  isFCY?: boolean | undefined;
  receiptNo?: string | undefined;
  fcyAmount?: number | undefined;
  currencyRate?: number | undefined;
}

export interface CreateReverseTransferCommand {
  id?: number;
}

export interface CreateShareholderCommand {
  name?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  amharicName?: string | undefined;
  amharicMiddleName?: string | undefined;
  amharicLastName?: string | undefined;
  accountNumber?: string | undefined;
  gender?: Gender;
  countryOfCitizenship?: number;
  shareholderType?: ShareholderTypeEnum;
  status?: number;
  tinNumber?: string | undefined;
  fileNumber?: string | undefined;
  isOtherBankMajorShareholder?: boolean;
  hasRelatives?: boolean;
  registrationDate?: string;
}

export interface CreateSubscriptionCommand {
  id?: number;
  subscriptionID?: string | undefined;
  subscriptionShareHolderID?: number;
  subscriptionAllocationID?: number;
  subscriptionGroupID?: number;
  subscriptionTransferID?: number;
  subscriptionAmount?: number;
  subscriptionBalance?: number;
  subscriptionDate?: string | undefined;
  subscriptionPaidUpAmount?: number;
  subscriptionOutstandingAmount?: number;
  subscriptionDistrictID?: string | undefined;
  subscriptionBranchID?: number;
  approvedBy?: string | undefined;
  subscriptionRemark?: string | undefined;
  subscriptionStatus?: SubscriptionStatus;
  subscriptionReferenceNo?: string | undefined;
  subscriptionOriginalRefrenceNo?: string | undefined;
  photoUrl?: string | undefined;
  photoId?: string | undefined;
  isFCY?: boolean | undefined;
  receiptNo?: string | undefined;
  fcyAmount?: number | undefined;
  currencyRate?: number | undefined;
}

export interface CreateSubscriptionGroupCommand {
  id?: number;
  allocationID?: number;
  premium?: number | undefined;
  expireDate?: string;
  subscriptionGroupName?: string | undefined;
  minimumSubscription?: number;
}

export interface CreateTransferCommand {
  transferInfo?: TransferInfo;
}

export interface CreateTransferDetailCommand {
  id?: number;
  transferReferenceNo?: string | undefined;
  transferOriginalReferenceNo?: string | undefined;
  paymentReferenceNo?: string | undefined;
  paymentAmount?: number;
  paymentShare?: number;
}

export interface DiscardPaymentCommand {
  id?: number;
  remark?: string | undefined;
}

export interface DiscardTransferCommand {
  id?: number;
  remark?: string | undefined;
}

export interface DistrictDto {
  id?: number;
  districtName?: string | undefined;
  districtCode?: string | undefined;
}

export interface FamilyDto {
  id?: number;
  name?: string | undefined;
  members?: ShareholderBasicInfo[] | undefined;
}

export enum Gender {
  Male = 1,
  Female = 2,
}

export interface GetFamiliesRequest {
  shareholderIds?: number[] | undefined;
}

export interface GetSubscriptionAllocationQuery {
  id?: number;
  shareholderID?: number;
  subscriptionAllocationAmount?: number;
  expireDate?: string;
  allocationID?: number;
}

export interface IdentityUserClaimOfString {
  id?: number;
  userId?: string | undefined;
  claimType?: string | undefined;
  claimValue?: string | undefined;
}

export interface IdentityUserRoleOfString {
  userId?: string | undefined;
  roleId?: string | undefined;
}

export interface LoginDto {
  email?: string | undefined;
  password?: string | undefined;
}

export interface LookupDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
}

export interface LookupsDto {
  shareholderTypes?: ShareholderType[] | undefined;
  countries?: CountryDto[] | undefined;
  allocation?: CreateAllocationCommand[] | undefined;
  allocationLookup?: CreateAllocationCommand[] | undefined;
  shareholder?: ShareholderDetailsDto[] | undefined;
  paymentTypes?: PaymentType[] | undefined;
  branch?: BranchDto[] | undefined;
  district?: DistrictDto[] | undefined;
  subscriptionGroup?: CreateSubscriptionGroupCommand[] | undefined;
  subscriptions?: CreateSubscriptionCommand[] | undefined;
  transferTypes?: LookupDto[] | undefined;
  transferCatagories?: LookupDto[] | undefined;
  transferDividendTerms?: LookupDto[] | undefined;
  paymentTransactionTypes?: LookupDto[] | undefined;
  foreignCurrencyTypes?: LookupDto[] | undefined;
}

export interface PaymentDetailsDto {
  id?: number;
  paymentAmount?: number;
  effectivePaymentDate?: string | undefined;
  paymentType?: PaymentTypeEnum;
  type?: PaymentType;
  subscriptionId?: number;
  shareHolderId?: number;
  branchId?: number | undefined;
  referenceNo?: string | undefined;
  remark?: string | undefined;
  paymentTransactionType?: number;
  currencyRate?: number | undefined;
  receiptNo?: string | undefined;
  isFCY?: boolean | undefined;
  fcyAmount?: number | undefined;
  foreignCurrencyType?: number | undefined;
  balance?: number;
  photoUrl?: string | undefined;
  photoId?: string | undefined;
}

export interface PaymentInfo {
  id?: number;
  paymentAmount?: number;
  effectivePaymentDate?: string | undefined;
  paymentType?: PaymentTypeEnum;
  type?: PaymentType;
  subscriptionId?: number;
  shareHolderId?: number;
  branchId?: number | undefined;
  referenceNo?: string | undefined;
  remark?: string | undefined;
  paymentTransactionType?: number;
  currencyRate?: number | undefined;
  receiptNo?: string | undefined;
  isFCY?: boolean | undefined;
  fcyAmount?: number | undefined;
  foreignCurrencyType?: number | undefined;
  balance?: number;
  photoUrl?: string | undefined;
  photoId?: string | undefined;
}

export interface PaymentListVm {
  payments?: PaymentDetailsDto[] | undefined;
}

export interface PaymentType {
  value?: PaymentTypeEnum;
  displayName?: string | undefined;
  description?: string | undefined;
}

export enum PaymentTypeEnum {
  SubscriptionPayment = 1,
  DividendCaptitalize = 2,
  TransferPayment = 3,
}

export interface ProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;
}

export interface RegisterDto {
  email?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  roles?: string[] | undefined;
}

export interface RejectSubscriptionCommand {
  id?: number;
  subscriptionShareHolderID?: number;
  subscriptionAllocationID?: number;
  subscriptionTransferID?: number;
  subscriptionAmount?: number;
  subscriptionBalance?: number;
  subscriptionDate?: string | undefined;
  subscriptionPaidUpAmount?: number;
  subscriptionOutstandingAmount?: number;
  subscriptionGroupID?: number;
  subscriptionDistrictID?: string | undefined;
  subscriptionBranchID?: number;
  approvedBy?: string | undefined;
  subscriptionRemark?: string | undefined;
  subscriptionStatus?: SubscriptionStatus;
}

export interface RemoveFamilyMembersRequest {
  familyId?: number;
  shareholderId?: number;
}

export interface ReturnAllocationCommand {
  id?: number;
  allocationDescription?: string | undefined;
  allocationName?: string | undefined;
  allocationDate?: string;
  allocationStatus?: AllocationStatus;
  allocationAmount?: number;
  fromDate?: string;
  toDate?: string;
}

export interface ReturnPaymentCommand {
  id?: number;
  remark?: string | undefined;
}

export interface ReturnSubscriptionCommand {
  id?: number;
  subscriptionRemark?: string | undefined;
}

export interface ReturnTransferCommand {
  id?: number;
  remark?: string | undefined;
}

export interface Role {
  id?: string | undefined;
  name?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
}

export interface SMSUser {
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: string | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  roles?: IdentityUserRoleOfString[] | undefined;
  claims?: IdentityUserClaimOfString[] | undefined;
}

export interface ShareholderBasicInfo {
  id?: number;
  name?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  displayName?: string | undefined;
  amharicName?: string | undefined;
  amharicMiddleName?: string | undefined;
  amharicLastName?: string | undefined;
  amharicDisplayName?: string | undefined;
  accountNumber?: string | undefined;
  dateOfBirth?: string;
  gender?: Gender;
  countryOfCitizenship?: number;
  type?: ShareholderType;
  shareholderType?: ShareholderTypeEnum;
  status?: number;
  approvalStatus?: ApprovalStatus;
  tinNumber?: string | undefined;
  fileNumber?: string | undefined;
  isNew?: boolean;
  isOtherBankMajorShareholder?: boolean;
  hasRelatives?: boolean;
  registrationDate?: string;
  photoUrl?: string | undefined;
  photoId?: string | undefined;
  signatureId?: string | undefined;
}

export interface ShareholderDetailsDto {
  id?: number;
  name?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  displayName?: string | undefined;
  amharicName?: string | undefined;
  amharicMiddleName?: string | undefined;
  amharicLastName?: string | undefined;
  amharicDisplayName?: string | undefined;
  accountNumber?: string | undefined;
  dateOfBirth?: string;
  gender?: Gender;
  countryOfCitizenship?: number;
  type?: ShareholderType;
  shareholderType?: ShareholderTypeEnum;
  status?: number;
  approvalStatus?: ApprovalStatus;
  tinNumber?: string | undefined;
  fileNumber?: string | undefined;
  isNew?: boolean;
  isOtherBankMajorShareholder?: boolean;
  hasRelatives?: boolean;
  registrationDate?: string;
  photoUrl?: string | undefined;
  photoId?: string | undefined;
  signatureId?: string | undefined;
  addresses?: AddressDto[] | undefined;
  contacts?: ContactDto[] | undefined;
  families?: FamilyDto[] | undefined;
}

export interface ShareholderType {
  value?: ShareholderTypeEnum;
  displayName?: string | undefined;
  description?: string | undefined;
}

export enum ShareholderTypeEnum {
  Individual = 1,
  Organization = 2,
  Association = 3,
  Church = 4,
  Edir = 5,
}

export enum SubscriptionStatus {
  Null = 0,
  Pending = 1,
  Approved = 2,
  Returned = 3,
  Cancle = 4,
  Reverse = 5,
  Posted = 6,
  Save = 8,
  Reject = 9,
  ReverseApproved = 10,
  ReversePending = 11,
  Discard = 12,
}

export interface TransferDetailsDto {
  id?: number;
  shareholderfromId?: number;
  shareholdertoId?: number;
  referenceNo?: string | undefined;
  originalReferenceNo?: string | undefined;
  transferCatagory?: number;
  transferAmount?: number;
  isFullTransfer?: boolean;
  transferShareValue?: number;
  transferStatus?: TransferStatus;
  transfertype?: number;
  courtNo?: string | undefined;
  isMultipleTransfer?: boolean | undefined;
  remark?: string | undefined;
  approvedBy?: string | undefined;
  transferAgreementDate?: string;
  dividenterms?: number;
  agreementForm?: string | undefined;
  serviceCharge?: number;
}

export interface TransferInfo {
  id?: number;
  shareholderfromId?: number;
  shareholdertoId?: number;
  referenceNo?: string | undefined;
  originalReferenceNo?: string | undefined;
  transferCatagory?: number;
  transferAmount?: number;
  isFullTransfer?: boolean;
  transferShareValue?: number;
  transferStatus?: TransferStatus;
  transfertype?: number;
  courtNo?: string | undefined;
  isMultipleTransfer?: boolean | undefined;
  remark?: string | undefined;
  approvedBy?: string | undefined;
  transferAgreementDate?: string;
  dividenterms?: number;
  agreementForm?: string | undefined;
  serviceCharge?: number;
}

export enum TransferStatus {
  Pending = 1,
  Returned = 2,
  Discard = 3,
  Approved = 4,
  Posted = 5,
  Reverse = 6,
  ReverseApprove = 7,
  ReversePending = 8,
}

export interface UpdateAllocationCommand {
  id?: number;
  allocationName?: string | undefined;
  allocationDate?: string;
  allocationAmount?: number;
  fromDate?: string;
  toDate?: string;
  allocationDescription?: string | undefined;
}

export interface UpdatePaymentCommand {
  paymentInfo?: PaymentInfo;
}

export interface UpdateShareHolderCommand {
  id?: number;
  name?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  amharicName?: string | undefined;
  amharicMiddleName?: string | undefined;
  amharicLastName?: string | undefined;
  countryOfCitizenship?: number;
  accountNumber?: string | undefined;
  tinNumber?: string | undefined;
  fileNumber?: string | undefined;
  isOtherBankMajorShareholder?: boolean;
  hasRelatives?: boolean;
  registrationDate?: string;
}

export interface UpdateSubscriptionCommand {
  id?: number;
  subscriptionID?: string | undefined;
  subscriptionShareHolderID?: number;
  subscriptionAllocationID?: number;
  subscriptionTransferID?: number;
  subscriptionAmount?: number;
  subscriptionBalance?: number;
  subscriptionDate?: string | undefined;
  subscriptionPaidUpAmount?: number;
  subscriptionOutstandingAmount?: number;
  subscriptionGroupID?: number;
  subscriptionDistrictID?: string | undefined;
  subscriptionBranchID?: number;
  approvedBy?: string | undefined;
  subscriptionRemark?: string | undefined;
  subscriptionStatus?: SubscriptionStatus;
  subscriptionReferenceNo?: string | undefined;
  subscriptionOriginalRefrenceNo?: string | undefined;
  isFCY?: boolean | undefined;
  fcyAmount?: number | undefined;
  currencyRate?: number | undefined;
  photoUrl?: string | undefined;
  photoId?: string | undefined;
  receiptNo?: string | undefined;
}

export interface UpdateTransferCommand {
  transferInfo?: TransferInfo;
}

export interface UserDetail {
  id?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  accessFailedCount?: number;
  roles?: Role[] | undefined;
  claims?: Claim[] | undefined;
}

export interface UserDto {
  id?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  roles?: string[] | undefined;
  readonly fullName?: string | undefined;
}

export interface ValidationProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  readonly errors?: { [key: string]: string[] } | undefined;

  [key: string]: any;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
